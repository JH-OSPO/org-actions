name: "ScanCode License Scanner"
description: "Simple ScanCode toolkit runner that scans for licenses and shows results"
author: "Your Name"
inputs:
  scan-path:
    description: "Path inside the target repo to scan"
    required: false
    default: "."
  file-path:
    description: "The path to check for citation and swhid"
    required: true
    default: "./citation.cff"

outputs:
  doi-value:
    description: 'The value of the "doi" key, or an empty string if not found.'
    value: ${{ steps.check.outputs.doi-value }}
  swhid-value:
    description: 'The value of the "swhid" key, or an empty string if not found.'
    value: ${{ steps.check.outputs.swhid-value }}

runs:
  using: "composite"
  steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.12.3"

    - name: Install ScanCode Toolkit
      shell: bash
      run: |
        echo "Installing ScanCode Toolkit..."
        python -m pip install --upgrade pip
        pip install scancode-toolkit "boolean.py>=4.0" "click==7.1.2"
    
    - name: Install yq
      shell: bash
      run: |
        sudo apt-get update
        sudo apt-get install -y wget
        wget https://github.com/mikefarah/yq/releases/download/v4.44.2/yq_linux_amd64 -O /usr/bin/yq
        sudo chmod +x /usr/bin/yq
    
    - name: Run ScanCode License Scan
      shell: bash
      run: |
        echo "Running ScanCode license scan on: ${{ inputs.scan-path }}"
        mkdir -p scancode-results
        scancode --license --only-findings --json-pp scancode-results/results.json "${{ inputs.scan-path }}" --ignore "*/venv/*"

    - name: Debug ScanCode Output
      shell: bash
      run: |
        echo "--- ScanCode JSON Output ---"
        cat scancode-results/results.json || echo "No results.json file found."

    - name: Check for Licenses
      id: license-check
      shell: python
      run: |
        import json
        import os
        
        output_file = 'scancode-results/results.json'
        
        if not os.path.exists(output_file):
            print("Error: The results file was not found.")
            print("::set-output name=has_licenses::false")
            print("::set-output name=comment_body::No scan results file found.")
            exit(1)

        with open(output_file, 'r') as f:
            data = json.load(f)
        
        # Check if the scan itself returned any results
        if not data.get('files', []):
            comment_body = "### ⚠️ ScanCode Check: NO FILES SCANNED\n\n"
            comment_body += "No files were found to scan, or the scan failed to produce a valid output."
            print("::set-output name=has_licenses::false")
            print(f"::set-output name=comment_body::{comment_body}")
            exit(0)

        # Check for license detections from the `license_detections` array
        licenses = data.get('license_detections', [])
        
        comment_body = ""
        has_licenses = "false"
        
        if licenses:
            has_licenses = "true"
            comment_body += "### ✅ ScanCode License Check: SUCCESS\n\n"
            comment_body += "The following licenses were detected:\n\n"
            comment_body += "| License Expression | Files |\n"
            comment_body += "|---|---|\n"
        
            for license_item in licenses:
                license_expression = license_item['license_expression']
                file_paths = [match['from_file'] for match in license_item['reference_matches']]
                comment_body += f"| `{license_expression}` | `{', '.join(file_paths)}` |\n"
        else:
            comment_body += "### ⚠️ ScanCode License Check: NO LICENSES DETECTED\n\n"
            comment_body += "No license information was found in the scanned files."
        
        print(f"::set-output name=has_licenses::{has_licenses}")
        print(f"::set-output name=comment_body::{comment_body}")
    
    - name: Check Keys and Extract Values
      id: check
      shell: bash
      run: |
        CFF_FILE="citation.cff"
        extract_value() {
          local KEY_TYPE="$1"
          local FILE="$2"
          # Use "streq" for robust string comparison in yq
          yq '.identifiers[] | select(.type == "'"$KEY_TYPE"'") | .value' "$FILE" 2>/dev/null
        }

        DOI_VALUE=$(extract_value "doi" "$CFF_FILE" || echo "")
        
        if [ -n "$DOI_VALUE" ]; then
          echo "Found DOI value: $DOI_VALUE"
          echo "doi-value=$DOI_VALUE" >> $GITHUB_OUTPUT
        else
          echo "DOI identifier not found."
          echo "doi-value=" >> $GITHUB_OUTPUT
        fi

        SWHID_VALUE=$(extract_value "swhid" "$CFF_FILE" || echo "")
        
        if [ -n "$SWHID_VALUE" ]; then
          echo "Found SWHID value: $SWHID_VALUE"
          echo "swhid-value=$SWHID_VALUE" >> $GITHUB_OUTPUT
        else
          echo "SWHID identifier not found."
          echo "swhid-value=" >> $GITHUB_OUTPUT
        fi
    
    - name: Create or Update Pull Request Comment
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v6
      with:
        script: |
          const commentBody = `${{ steps.license-check.outputs.comment_body }}`
          const pull_request_number = context.issue.number;
          const { owner, repo } = context.repo;
          
          // Check if a previous comment from this bot exists
          const { data: comments } = await github.rest.issues.listComments({
            owner,
            repo,
            issue_number: pull_request_number,
          });

          const existingComment = comments.find(
            (comment) => comment.body.includes('### ScanCode License Check')
          );

          if (existingComment) {
            // Update the existing comment
            github.rest.issues.updateComment({
              owner,
              repo,
              comment_id: existingComment.id,
              body: commentBody
            });
          } else {
            // Create a new comment
            github.rest.issues.createComment({
              owner,
              repo,
              issue_number: pull_request_number,
              body: commentBody
            });
          }
    